/*
 *  huffman.c -- functions do decompress files in mpq files which
 *               uses a modified huffman version.
 *
 *  Copyright (c) 2003-2011 Maik Broemme <mbroemme@libmpq.org>
 *
 *  Differences between C++ and C version:
 *
 *    - Removed the object oriented stuff.
 *    - Replaced the goto things with some better C code.
 *
 *  This source was adepted from the C++ version of huffman.cpp included
 *  in stormlib. The C++ version belongs to the following authors:
 *
 *  Ladislav Zezula <ladik@zezula.net>
 *  ShadowFlare <BlakFlare@hotmail.com>
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

/* generic includes. */
#include <stdlib.h>
#include <string.h>

/* libmpq main includes. */
#include "mpq.h"
#include "mpq-internal.h"

/* libmpq generic includes. */
#include "huffman.h"

/* a virtual tree item that represents the head of the item list */
#define LIST_HEAD(ht)		((struct huffman_tree_item_s *)(&ht->first))

/* tables for decompression. every compression type has 258 entries. */
static const uint8_t byte_to_weight_00[] = {

	0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
	0x00, 0x00
};

static const uint8_t byte_to_weight_01[] = {

	0x54, 0x16, 0x16, 0x0D, 0x0C, 0x08, 0x06, 0x05, 0x06, 0x05, 0x06, 0x03, 0x04, 0x04, 0x03, 0x05,
	0x0E, 0x0B, 0x14, 0x13, 0x13, 0x09, 0x0B, 0x06, 0x05, 0x04, 0x03, 0x02, 0x03, 0x02, 0x02, 0x02,
	0x0D, 0x07, 0x09, 0x06, 0x06, 0x04, 0x03, 0x02, 0x04, 0x03, 0x03, 0x03, 0x03, 0x03, 0x02, 0x02,
	0x09, 0x06, 0x04, 0x04, 0x04, 0x04, 0x03, 0x02, 0x03, 0x02, 0x02, 0x02, 0x02, 0x03, 0x02, 0x04,
	0x08, 0x03, 0x04, 0x07, 0x09, 0x05, 0x03, 0x03, 0x03, 0x03, 0x02, 0x02, 0x02, 0x03, 0x02, 0x02,
	0x03, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x01, 0x01, 0x01, 0x02, 0x01, 0x02, 0x02,
	0x06, 0x0A, 0x08, 0x08, 0x06, 0x07, 0x04, 0x03, 0x04, 0x04, 0x02, 0x02, 0x04, 0x02, 0x03, 0x03,
	0x04, 0x03, 0x07, 0x07, 0x09, 0x06, 0x04, 0x03, 0x03, 0x02, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02,
	0x0A, 0x02, 0x02, 0x03, 0x02, 0x02, 0x01, 0x01, 0x02, 0x02, 0x02, 0x06, 0x03, 0x05, 0x02, 0x03,
	0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x03, 0x01, 0x01, 0x01,
	0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x04, 0x04, 0x04, 0x07, 0x09, 0x08, 0x0C, 0x02,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x03,
	0x04, 0x01, 0x02, 0x04, 0x05, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01,
	0x04, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x01, 0x01, 0x02, 0x02, 0x02, 0x06, 0x4B,
	0x00, 0x00
};

static const uint8_t byte_to_weight_02[] = {

	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x27, 0x00, 0x00, 0x23, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFF, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x01, 0x01, 0x06, 0x0E, 0x10, 0x04,
	0x06, 0x08, 0x05, 0x04, 0x04, 0x03, 0x03, 0x02, 0x02, 0x03, 0x03, 0x01, 0x01, 0x02, 0x01, 0x01,
	0x01, 0x04, 0x02, 0x04, 0x02, 0x02, 0x02, 0x01, 0x01, 0x04, 0x01, 0x01, 0x02, 0x03, 0x03, 0x02,
	0x03, 0x01, 0x03, 0x06, 0x04, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x02, 0x01, 0x01,
	0x01, 0x29, 0x07, 0x16, 0x12, 0x40, 0x0A, 0x0A, 0x11, 0x25, 0x01, 0x03, 0x17, 0x10, 0x26, 0x2A,
	0x10, 0x01, 0x23, 0x23, 0x2F, 0x10, 0x06, 0x07, 0x02, 0x09, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00
};

static const uint8_t byte_to_weight_03[] = {

	0xFF, 0x0B, 0x07, 0x05, 0x0B, 0x02, 0x02, 0x02, 0x06, 0x02, 0x02, 0x01, 0x04, 0x02, 0x01, 0x03,
	0x09, 0x01, 0x01, 0x01, 0x03, 0x04, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01,
	0x05, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x02, 0x01, 0x01, 0x03, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x01,
	0x0A, 0x04, 0x02, 0x01, 0x06, 0x03, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x01,
	0x05, 0x02, 0x03, 0x04, 0x03, 0x03, 0x03, 0x02, 0x01, 0x01, 0x01, 0x02, 0x01, 0x02, 0x03, 0x03,
	0x01, 0x03, 0x01, 0x01, 0x02, 0x05, 0x01, 0x01, 0x04, 0x03, 0x05, 0x01, 0x03, 0x01, 0x03, 0x03,
	0x02, 0x01, 0x04, 0x03, 0x0A, 0x06, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x02, 0x02, 0x01, 0x0A, 0x02, 0x05, 0x01, 0x01, 0x02, 0x07, 0x02, 0x17, 0x01, 0x05, 0x01, 0x01,
	0x0E, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x06, 0x02, 0x01, 0x04, 0x05, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x01,
	0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x11,
	0x00, 0x00
};

static const uint8_t byte_to_weight_04[] = {

	0xFF, 0xFB, 0x98, 0x9A, 0x84, 0x85, 0x63, 0x64, 0x3E, 0x3E, 0x22, 0x22, 0x13, 0x13, 0x18, 0x17,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00
};

static const uint8_t byte_to_weight_05[] = {

	0xFF, 0xF1, 0x9D, 0x9E, 0x9A, 0x9B, 0x9A, 0x97, 0x93, 0x93, 0x8C, 0x8E, 0x86, 0x88, 0x80, 0x82,
	0x7C, 0x7C, 0x72, 0x73, 0x69, 0x6B, 0x5F, 0x60, 0x55, 0x56, 0x4A, 0x4B, 0x40, 0x41, 0x37, 0x37,
	0x2F, 0x2F, 0x27, 0x27, 0x21, 0x21, 0x1B, 0x1C, 0x17, 0x17, 0x13, 0x13, 0x10, 0x10, 0x0D, 0x0D,
	0x0B, 0x0B, 0x09, 0x09, 0x08, 0x08, 0x07, 0x07, 0x06, 0x05, 0x05, 0x04, 0x04, 0x04, 0x19, 0x18,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00
};

static const uint8_t byte_to_weight_06[] = {

	0xC3, 0xCB, 0xF5, 0x41, 0xFF, 0x7B, 0xF7, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xBF, 0xCC, 0xF2, 0x40, 0xFD, 0x7C, 0xF7, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x7A, 0x46, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00
};

static const uint8_t byte_to_weight_07[] = {

	0xC3, 0xD9, 0xEF, 0x3D, 0xF9, 0x7C, 0xE9, 0x1E, 0xFD, 0xAB, 0xF1, 0x2C, 0xFC, 0x5B, 0xFE, 0x17,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xBD, 0xD9, 0xEC, 0x3D, 0xF5, 0x7D, 0xE8, 0x1D, 0xFB, 0xAE, 0xF0, 0x2C, 0xFB, 0x5C, 0xFF, 0x18,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x70, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00
};

static const uint8_t byte_to_weight_08[] = {

	0xBA, 0xC5, 0xDA, 0x33, 0xE3, 0x6D, 0xD8, 0x18, 0xE5, 0x94, 0xDA, 0x23, 0xDF, 0x4A, 0xD1, 0x10,
	0xEE, 0xAF, 0xE4, 0x2C, 0xEA, 0x5A, 0xDE, 0x15, 0xF4, 0x87, 0xE9, 0x21, 0xF6, 0x43, 0xFC, 0x12,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xB0, 0xC7, 0xD8, 0x33, 0xE3, 0x6B, 0xD6, 0x18, 0xE7, 0x95, 0xD8, 0x23, 0xDB, 0x49, 0xD0, 0x11,
	0xE9, 0xB2, 0xE2, 0x2B, 0xE8, 0x5C, 0xDD, 0x15, 0xF1, 0x87, 0xE7, 0x20, 0xF7, 0x44, 0xFF, 0x13,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x5F, 0x9E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00
};

static const uint8_t *weight_tables[0x09] = {

	byte_to_weight_00,
	byte_to_weight_01,
	byte_to_weight_02,
	byte_to_weight_03,
	byte_to_weight_04,
	byte_to_weight_05,
	byte_to_weight_06,
	byte_to_weight_07,
	byte_to_weight_08
};

/* creates a new item for the huffman tree. */
struct huffman_tree_item_s *libmpq__create_new_item(struct huffman_tree_s *ht, uint32_t dcmp_byte, uint32_t weight, uint32_t where) {

	struct huffman_tree_item_s *new_item = NULL;

	/* don't let the item buffer run out of space. */
	if (ht->items_used < HUFF_ITEM_COUNT) {

		/* allocate new item from the item pool. */
		new_item = &ht->item_buffer[ht->items_used++];

		/* insert this item to the top of the tree. */
		libmpq__huffman_insert_item(ht, new_item, where, NULL);

		/* fill the rest of the item. */
		new_item->dcmp_byte = dcmp_byte;
		new_item->weight = weight;
		new_item->parent = NULL;
		new_item->child = NULL;
	}

	return new_item;
}

/* this function insert an item to a huffman tree. */
void libmpq__huffman_insert_item(struct huffman_tree_s *ht, struct huffman_tree_item_s *hi, uint32_t where, struct huffman_tree_item_s *insert_point) {

	libmpq__huffman_remove_item(hi);

	if (insert_point == NULL)
		insert_point = LIST_HEAD(ht);

	switch (where) {

		case INSERT_AFTER:
			libmpq__link_two_items(insert_point, hi);
			return;

		case INSERT_BEFORE:
			hi->next = insert_point;
			hi->prev = insert_point->prev;
			insert_point->prev->next = hi;
			insert_point->prev = hi;
			return;
	}
}

/* remove item from huffman tree.*/
void libmpq__huffman_remove_item(struct huffman_tree_item_s *hi) {

	if (hi->next != NULL) {

		hi->prev->next = hi->next;
		hi->next->prev = hi->prev;
		hi->next = hi->prev = NULL;
	}
}

/* insert item2 after item1. */
void libmpq__link_two_items(struct huffman_tree_item_s *item1, struct huffman_tree_item_s *item2) {

	item2->next = item1->next;
	item2->prev = item1->next->prev;
	item1->next->prev = item2;
	item1->next = item2;
}

/* get huffman tree item with higher weight. */
struct huffman_tree_item_s *libmpq__huffman_find_higher_or_equal_item(struct huffman_tree_s *ht, struct huffman_tree_item_s *hi, uint32_t weight) {

	/* parse all existing items. */
	if (hi != NULL) {

		while (hi != LIST_HEAD(ht)) {

			if (hi->weight >= weight)
				return hi;

			hi = hi->prev;
		}
	}

	/* if not found, we just get the first item. */
	return LIST_HEAD(ht);
}

/* get one bit from input stream. */
uint32_t libmpq__huffman_get_1bit(struct huffman_input_stream_s *is) {

	uint32_t bit = 0;

	/* ensure that the input stream is reloaded, if there are no bits left. */
	if (is->bits == 0) {

		/* refill the bit buffer. */
		is->bit_buf = *is->in_buf++;
		is->bits    = 8;
	}

	/* copy the bit from bit buffer to the variable. */
	bit = (is->bit_buf & 1);
	is->bit_buf >>= 1;
	is->bits--;

	return bit;
}

/* get 7 bits from the input stream. DOES NOT remove the bits from input stream. */
uint32_t libmpq__huffman_peek_7bit(struct huffman_input_stream_s *is) {

	uint16_t reload_byte = 0;

	/*
	 * if there is not enough bits to get the value,
	 * we have to add 8 more bits from the input buffer.
	 */
	if (is->bits < 7) {

		reload_byte  = *is->in_buf++;
		is->bit_buf |= reload_byte << is->bits;
		is->bits    += 8;
	}

	/* return the first available 7 bits. DO NOT remove them from the input stream. */
	return (is->bit_buf & 0x7F);
}

/* get the whole byte from the input stream. */
uint32_t libmpq__huffman_get_8bit(struct huffman_input_stream_s *is) {

	uint16_t reload_byte = 0;
	uint32_t one_byte = 0;

	/*
	 * if there is not enough bits to get the value,
	 * we have to add 8 more bits from the input buffer.
	 */
	if (is->bits < 8) {

		reload_byte  = *is->in_buf++;
		is->bit_buf |= reload_byte << is->bits;
		is->bits    += 8;
	}

	/* return the lowest 8 bits. */
	one_byte      = (is->bit_buf & 0xFF);
	is->bit_buf >>= 8;
	is->bits     -= 8;

	return one_byte;
}

/* skip over bits in the input stream without using them. */
void libmpq__huffman_skip_bits(struct huffman_input_stream_s *is, uint32_t bits_to_skip) {

	uint16_t reload_byte = 0;

	/*
	 * if there is not enough bits in the buffer,
	 * we have to add 8 more bits from the input buffer.
	 */
	if (is->bits < bits_to_skip) {

		reload_byte = *is->in_buf++;
		is->bit_buf |= reload_byte << is->bits;
		is->bits += 8;
	}

	/* skip the remaining bits. */
	is->bit_buf >>= bits_to_skip;
	is->bits     -= bits_to_skip;
}

/* this function initialize a huffman tree. */
void libmpq__huffman_tree_init(struct huffman_tree_s *ht, uint32_t cmp) {

	ht->first = ht->last = LIST_HEAD(ht);
	ht->min_valid_value = 1;
	ht->items_used = 0;
	ht->isCmp0 = FALSE;

	memset(ht->items_by_byte, 0, sizeof(ht->items_by_byte));

	/*
	 * if we are going to decompress data, we need to invalidate all item links.
	 * we do so by zeroing their valid_value, so it becomes lower min_valid_value.
	 */
	if (cmp == LIBMPQ_HUFF_DECOMPRESS) {

		memset(ht->quick_links, 0, sizeof(ht->quick_links));
	}
}

/* this function build a huffman tree, called with the first 8 bits loaded from input stream. */
int libmpq__huffman_tree_build(struct huffman_tree_s *ht, uint32_t cmp_type) {

	struct huffman_tree_item_s *new_item;
	struct huffman_tree_item_s *child_lo;
	struct huffman_tree_item_s *child_hi;
	const uint8_t *weight_table;
	uint32_t max_weight;		/* the greatest character found in table. */

	/* clear all pointers in huffman tree item array. */
	memset(ht->items_by_byte, 0, sizeof(ht->items_by_byte));
	max_weight = 0;

	/* ensure that the compression type is in range. */
	if ((cmp_type & 0x0F) > 0x08)
		return FALSE;
	weight_table = weight_tables[cmp_type & 0x0F];

	/* build the linear list of entries that is sorted by byte weight. */
	for (size_t i = 0; i < 0x100; i++) {

		/* skip all the bytes which are zero. */
		if (weight_table[i] != 0) {

			/* create new tree item. */
			ht->items_by_byte[i] = new_item = libmpq__create_new_item(ht, i, weight_table[i], INSERT_AFTER);

			/* we need to put the item to the right place in the list. */
			max_weight = libmpq__fixup_item_pos_by_weight(ht, new_item, max_weight);
		}
	}

	/* insert termination entries at the end of the list. */
	ht->items_by_byte[0x100] = libmpq__create_new_item(ht, 0x100, 1, INSERT_BEFORE);
	ht->items_by_byte[0x101] = libmpq__create_new_item(ht, 0x101, 1, INSERT_BEFORE);

	/*
	 * now we need to build the tree. we start at the
	 * last entry and go backwards to the first one.
	 */
	child_lo = ht->last;

	/*
	 * work as long as both children are valid.
	 * child_hi is child with higher weight, child_lo is the one with lower weight.
	 */
	while(child_lo != LIST_HEAD(ht))
	{
		/* also get and verify the higher-weight child. */
		child_hi = child_lo->prev;
		if (child_hi == LIST_HEAD(ht))
			break;

		/* create new parent item for the children. */
		new_item = libmpq__create_new_item(ht, 0, child_hi->weight + child_lo->weight, INSERT_AFTER);
		if (new_item == NULL)
			return FALSE;

		/* link both child items to their new parent. */
		child_lo->parent   = new_item;
		child_hi->parent   = new_item;
		new_item->child = child_lo;

		/* fixup the item's position by its weight. */
		max_weight = libmpq__fixup_item_pos_by_weight(ht, new_item, max_weight);

		/* get the previous lower-weight child. */
		child_lo = child_hi->prev;
	}

	/* initialize the min_valid_value to 1, which invalidates all quick-link items. */
	ht->min_valid_value = 1;
	return TRUE;
}

uint32_t libmpq__decode_one_byte(struct huffman_tree_s *ht, struct huffman_input_stream_s *is) {

	struct huffman_tree_item_s *hi_link = NULL;
	struct huffman_tree_item_s *hi;
	uint32_t hi_link_idx;
	uint32_t bits = 0;

	/* check for the end of the input stream. */
	if (is->in_buf >= is->in_buf_end && is->bits < 7)
		return 0x1FF;

	/* get the eventual quick-link index. */
	hi_link_idx = libmpq__huffman_peek_7bit(is);

	/* is the quick-link item valid? */
	if (ht->quick_links[hi_link_idx].valid_value >= ht->min_valid_value) {

		/* if that item needs less than 7 bits, we can get decompressed value directly. */
		if (ht->quick_links[hi_link_idx].valid_bits <= 7) {

			libmpq__huffman_skip_bits(is, ht->quick_links[hi_link_idx].valid_bits);
			return ht->quick_links[hi_link_idx].dcmp_byte;
		}

		/*
		 * otherwise we cannot get decompressed value directly
		 * but we can skip 7 levels of tree parsing.
		 */
		hi = ht->quick_links[hi_link_idx].hi;
		libmpq__huffman_skip_bits(is, 7);
	} else {

		/* just a sanity check. */
		if (ht->first == LIST_HEAD(ht))
			return 0x1FF;

		/* we don't have the quick-link item, we need to parse the tree from its root. */
		hi = ht->first;
	}

	/* step down the tree until we find a terminal item. */
	while (hi->child != NULL) {

		/*
		 * if the next bit in the compressed stream is set, we get the higher-weight
		 * child. otherwise, get the lower-weight child.
		 */
		hi = libmpq__huffman_get_1bit(is) ? hi->child->prev : hi->child;
		bits++;

		/*
		 * if the number of loaded bits reached 7,
		 * remember the current item for storing into quick-link item array.
		 */
		if (bits == 7)
			hi_link = hi;
	}

	/*
	 * if we didn't get the item from the quick-link array,
	 * set the entry in it.
	 */
	if (ht->quick_links[hi_link_idx].valid_value < ht->min_valid_value) {

		/*
		 * if the current compressed byte was more than 7 bits,
		 * set a quick-link item with pointer to tree item.
		 */
		if (bits > 7) {

			ht->quick_links[hi_link_idx].valid_value = ht->min_valid_value;
			ht->quick_links[hi_link_idx].valid_bits  = bits;
			ht->quick_links[hi_link_idx].hi          = hi_link;
		} else {

			/*
			 * limit the quick-decompress item to lower amount of bits.
			 * coverity fix 84457: (x >> 32) has undefined behavior.
			 */
			hi_link_idx = (bits != 0) ? hi_link_idx & (0xFFFFFFFF >> (32 - bits)) : 0;

			while (hi_link_idx < LINK_ITEM_COUNT) {

				/* fill the quick-decompress item. */
				ht->quick_links[hi_link_idx].valid_value = ht->min_valid_value;
				ht->quick_links[hi_link_idx].valid_bits  = bits;
				ht->quick_links[hi_link_idx].dcmp_byte   = hi->dcmp_byte;

				/* increment the index. */
				hi_link_idx += (1 << bits);
			}
		}
	}

	/* return the decompressed value from the found item. */
	return hi->dcmp_byte;
}

/* this function did the real decompression. */
int32_t libmpq__do_decompress_huffman(struct huffman_tree_s *ht, struct huffman_input_stream_s *is, uint8_t *out_buf, uint32_t out_length) {

	uint8_t *out_buf_end = out_buf + out_length;
	uint8_t *out_buf_cur = out_buf;
	uint32_t dcmp_value = 0;
	uint32_t cmp_type = 0;

	/* test the output length. must not be empty. */
	if (out_length == 0)
		return 0;

	/* get the compression type from the input stream. */
	cmp_type = libmpq__huffman_get_8bit(is);
	ht->isCmp0 = (cmp_type == 0);

	/* build the huffman tree. */
	if (!libmpq__huffman_tree_build(ht, cmp_type))
		return 0;

	/* process the entire input buffer until end of the stream. */
	while ((dcmp_value = libmpq__decode_one_byte(ht, is)) != 0x100) {

		/* did an error occur? */
		if (dcmp_value == 0x1FF)
			return 0;

		/* huffman tree needs to be modified. */
		if (dcmp_value == 0x101) {

			/* the decompressed byte is stored in the next 8 bits. */
			dcmp_value = libmpq__huffman_get_8bit(is);

			if(!libmpq__insert_new_branch_and_rebalance(ht, ht->last->dcmp_byte, dcmp_value))
				return 0;

			if(ht->isCmp0 == 0)
				libmpq__inc_weights_and_rebalance(ht, ht->items_by_byte[dcmp_value]);
		}

		/* a byte successfully decoded - store it in the output stream. */
		*out_buf_cur++ = (uint8_t)dcmp_value;
		if (out_buf_cur >= out_buf_end)
			break;

		if (ht->isCmp0)
			libmpq__inc_weights_and_rebalance(ht, ht->items_by_byte[dcmp_value]);
	}

	return (int32_t)(out_buf_cur - out_buf);
}

/* maintain balance while inserting new item. */
int libmpq__insert_new_branch_and_rebalance(struct huffman_tree_s *ht, uint32_t value1, uint32_t value2) {

	struct huffman_tree_item_s *last_item = ht->last;
	struct huffman_tree_item_s *child_hi;
	struct huffman_tree_item_s *child_lo;

	/* create higher-weight child. */
	child_hi = libmpq__create_new_item(ht, value1, last_item->weight, INSERT_BEFORE);

	if (child_hi != NULL) {

		child_hi->parent = last_item;
		ht->items_by_byte[value1] = child_hi;

		/* create lower-weight child. */
		child_lo = libmpq__create_new_item(ht, value2, 0, INSERT_BEFORE);

		if (child_lo != NULL) {

			child_lo->parent = last_item;
			last_item->child = child_lo;
			ht->items_by_byte[value2] = child_lo;

			libmpq__inc_weights_and_rebalance(ht, child_lo);
			return TRUE;
		}
	}

	/* no more space in the tree buffer. */
	return FALSE;
}

/* find place for new item and fix weights. */
uint32_t libmpq__fixup_item_pos_by_weight(struct huffman_tree_s *ht, struct huffman_tree_item_s *new_item, uint32_t max_weight) {

	struct huffman_tree_item_s *hi_item;

	if (new_item->weight < max_weight) {

		/* find an item that has higher weight than this one. */
		hi_item = libmpq__huffman_find_higher_or_equal_item(ht, ht->last, new_item->weight);

		/* remove the item and put it to the new position. */
		libmpq__huffman_remove_item(new_item);
		libmpq__link_two_items(hi_item, new_item);
	} else {

		max_weight = new_item->weight;
	}

	/* return the (updated) maximum weight. */
	return max_weight;
}

/* maintain balance while fixing weights of item ancestors. */
void libmpq__inc_weights_and_rebalance(struct huffman_tree_s *ht, struct huffman_tree_item_s *item) {

	struct huffman_tree_item_s *hi_item;		/* a previous item with greater or equal weight. */
	struct huffman_tree_item_s *child_hi;		/* the higher-weight child. */
	struct huffman_tree_item_s *child_lo;		/* the lower-weight child. */
	struct huffman_tree_item_s *parent;

	/* climb up the tree and increment weight of each tree item. */
	for (; item != NULL; item = item->parent) {

		/* increment the item's weight. */
		item->weight++;

		/* find a previous item with equal or greater weight, which is not equal to this item. */
		hi_item = libmpq__huffman_find_higher_or_equal_item(ht, item->prev, item->weight);
		child_hi = hi_item->next;

		/* if the item is not equal to the tree item, we need to rebalance the tree. */
		if (child_hi != item) {

			/* move the previous item to the RIGHT from the given item. */
			libmpq__huffman_remove_item(child_hi);
			libmpq__link_two_items(item, child_hi);

			/* move the given item AFTER the greater-weight tree item. */
			libmpq__huffman_remove_item(item);
			libmpq__link_two_items(hi_item, item);

			/*
			 * we need to maintain the tree so that child_hi->weight is >= child_lo->weight.
			 * rebalance the tree accordingly.
			 */
			child_lo = child_hi->parent->child;
			parent = item->parent;
			if (parent->child == item)
				parent->child = child_hi;
			if (child_lo == child_hi)
				child_hi->parent->child = item;
			parent = item->parent;
			item->parent = child_hi->parent;
			child_hi->parent = parent;

			/* increment the global valid value. this invalidates all quick-link items. */
			ht->min_valid_value++;
		}
	}
}
